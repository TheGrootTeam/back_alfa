import request from 'supertest';
import express from 'express';
import { Request, Response, NextFunction } from 'express';
import { HttpError } from 'http-errors';
import LoginController from '../LoginController';
import Applicant from '../../models/Applicant';
//import Company from '../../models/Company';
import jwt from 'jsonwebtoken';


const app = express();
const loginController = new LoginController();

app.post('/login', loginController.post);
app.use((err: HttpError, _req: Request, res: Response, _next: NextFunction): void => {
  res.status(500).json({ message: err.message });
});

//to generate the token  (Alternative of this jest.mock -> jest.spyOn)
jest.mock('jsonwebtoken', () => ({
  sign: jest.fn()
}));


jest.mock('../../models/Applicant');
jest.mock('../../models/Company');

//Converts the mock modules into a typed version, making it easier to use in TypeScript.
const mockedApplicant = jest.mocked(Applicant);
//const mockedCompany = jest.mocked(Company);
const mockedJwt = jest.mocked(jwt);



describe('LoginController', () => {


  it('should log in an existing applicant user', async () => {
    const theMockedApplicant = [
      {
        dniCif: '000000000A',
        password: '123',
        isCompany: false,
        name: 'Antonio',
        email: 'antonio@mail.es',
        phone: '000000001',
        photo: 'url-foto',
        cv: 'url-cv',
        ubication: 'Madrid',
        role: 'presencial',
        typeJob: 'renumerado',
        wantedJob: 'lo que sea',
        geographically_mobile: false,
        disponibility: true,
        preferredOffers: [],
        suscribedOffers: [],
      }
    ];

    const mockedToken = 'mockedToken123';
    mockedApplicant.find.mockResolvedValue(theMockedApplicant);
    //@ts-expect-error obviamos error
    mockedJwt.sign.mockReturnValue(mockedToken);

    //const findSpy = jest.spyOn(mockedApplicant, 'find').mockResolvedValue(theMockedApplicant);
    //const signSpy = jest.spyOn(jwt, 'sign').mockReturnValue(mockedToken);

    //(jwt.sign as jest.Mock).mockReturnValue(mockedToken); // Mockea la generaciÃ³n del token



    //mockedApplicant.find.mockResolvedValue(theMockedApplicant);
    //mockedOffer.find.mockResolvedValue(mockedoffers);

    //const response = await request(app).post('/login').send(theMockedApplicant);
    const response = await request(app).post('/login');

    console.log('STATUS: ', response.status);
    console.log('Token definido: ', response.body.tokenJWT);


    expect(response.status).toBe(200);
    expect(response.body.tokenJWT).toBeDefined();
    expect(response.body.tokenJWT).toBe(mockedToken);
    expect(mockedApplicant.find).toHaveBeenCalledTimes(1);


    // findSpy.mockRestore();
    // signSpy.mockRestore();


  });

  // it('should return an error with status 500', async () => {
  //   const mockedErrorMessage = 'Internal Server Error';

  //   mockedOffer.find.mockRejectedValue(new Error(mockedErrorMessage));

  //   const response = await request(app).get('/offers');

  //   expect(response.status).toBe(500);
  //   expect(response.body.message).toBe(mockedErrorMessage);
  // });

});


